load_dotenv()
TOKEN = os.getenv("DISCORD_TOKEN")

intents = discord.Intents.default()
intents.message_content = True

queues = {}

def check_queue(ctx, id):
    if queues[id] != []:
        voice = ctx.guild.voice_client
        source = queues[id].pop(0)
        player = voice.play(source)

bot = commands.Bot(command_prefix= "!", intents=intents)

# event comands 
# / slash comands
@bot.event
async def on_ready():
    await bot.tree.sync()
    await bot.change_presence(status=discord.Status.online, activity=discord.Activity(type=discord.ActivityType.listening, name="your commands!" ))
    print(f"{bot.user} is online!")

# slash command /greet
@bot.tree.command(name="greet", description="Sends a greeting to the user")
async def greet(interaction: discord.Interaction):
    username = interaction.user.mention
    await interaction.response.send_message(f"Hello there, {username}")


# New Slash Command for Kick
# The "app_commands.describe" decorator provides the hover-text in Discord
@bot.tree.command(name="kick", description="Kicks a member from the server.")
@app_commands.checks.has_permissions(kick_members=True)
async def kick_slash(interaction: discord.Interaction, member: discord.Member, reason: str | None = None):
    # This check happens *before* the function runs
    
    try:
        await member.kick(reason=reason)
        await interaction.response.send_message(f"User **{member.display_name}** has been kicked. Reason: {reason or "None"}", ephemeral=True)
        # ephemeral=True makes the message only visible to the user who ran the command
        
    except discord.Forbidden:
        await interaction.response.send_message(" I do not have permission to kick this member.", ephemeral=True)
    except Exception as e:
        print(f"Kick error: {e}")
        await interaction.response.send_message("An unexpected error occurred during the kick operation.", ephemeral=True)

# Error handling for slash commands is done using a different structure:
@kick_slash.error
async def kick_slash_error(interaction: discord.Interaction, error: app_commands.AppCommandError):
    if isinstance(error, app_commands.MissingPermissions):
        await interaction.response.send_message("You do not have permission to kick members.", ephemeral=True)
    else:
        # Pass up other errors
        raise error



# !join command
@bot.command() # pass_context=True is redundant in modern discord.py (v2.0+) as the Context object (ctx) is passed by default. You can safely remove it
async def join(ctx):
    if (ctx.author.voice):
        channel = ctx.message.author.voice.channel
        voice = await channel.connect()
        source = FFmpegPCMAudio("#path_to_your_audio_file#.mp3")  # Replace with your audio file path
        voice.play(source)
    else:
        await ctx.send("You are not connected to a voice channel. You must be in a voice channel to run this command.")
        
# !leave command
@bot.command() # pass_context=True is redundant in modern discord.py (v2.0+) as the Context object (ctx) is passed by default. You can safely remove it
async def leave(ctx):
    if (ctx.voice_client):
        await ctx.guild.voice_client.disconnect()
        await ctx.send("I left the voice channel.")
    else:
        await ctx.send("I am not connected to a voice channel.") 

# playback commands
@bot.command()
async def pause(ctx):
    voice = ctx.voice_client

    if voice and voice.is_playing():
        voice.pause()
        await ctx.send("Paused the playback.")
    elif not voice:
        await ctx.send("Not connected to a voice channel.")
    else:
        await ctx.send("No audio is playing anything at the moment.")




@bot.command()
async def resume(ctx):
    voice = discord.utils.get(bot.voice_clients, guild=ctx.guild)
    if voice .is_paused():
        voice.resume()
    else:
        await ctx.send("The audio is not paused.")


@bot.command()
async def stop(ctx):
    voice = discord.utils.get(bot.voice_clients, guild=ctx.guild)
    voice.stop()


def get_check_queue_callback(ctx, guild_id):
    def check_queue(error):   # This function returns the function that will be executed after a song is done.
        if error:
            print(f"Player error: {error}")
            return
        
        if guild_id in queues and queues[guild_id]:
            next_source = queues[guild_id].pop(0)
            ctx.voice_client.play(next_source, after=get_check_queue_callback(ctx, guild_id))
        elif guild_id in queues:
            del queues[guild_id]  # Clear the queue dictionary key if the queue is empty
        
    return check_queue
            

